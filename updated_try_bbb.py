# -*- coding: utf-8 -*-
"""Updated_try_bbb.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HLGw9mt7eOdE1Q2NfXhiq1tuWlqHmoBj
"""

import pickle
import pandas as pd
import streamlit as st
from rdkit import Chem
from mordred import Calculator, descriptors
from rdkit.Chem import GetMolFrags

# Load the model and selected_features from the pickle file
filename = "BBB_model_des_3d.sav"
with open(filename, 'rb') as f:
    loaded_model, selected_features = pickle.load(f)

# Function to convert SMILES to isomeric SMILES
def convert_to_isomeric_smiles(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        isomeric_smiles = Chem.MolToSmiles(mol, isomericSmiles=True)
        return isomeric_smiles
    else:
        return None

# Function to calculate descriptors from SMILES
def calculate_descriptors(smiles):
    isomeric_smiles = convert_to_isomeric_smiles(smiles)
    if isomeric_smiles is not None:
        data = {'SMILES': [smiles], 'Isomeric SMILES': [isomeric_smiles]}
        df = pd.DataFrame(data)

        # Initialize descriptor calculator
        calc = Calculator(descriptors, ignore_3D=False)

        # Read SMILES from the DataFrame
        molecules = df['Isomeric SMILES']

        # Convert valid SMILES to RDKit Mol objects and filter out molecules with disconnected fragments
        mols = []
        valid_molecules = []
        for smi in molecules:
            if smi is not None:
                mol = Chem.MolFromSmiles(smi)
                if mol is not None:
                    fragments = GetMolFrags(mol)
                    if len(fragments) == 1:  # Exclude molecules with multiple fragments
                        mols.append(mol)
                        valid_molecules.append(smi)

        # Generate descriptors
        descriptors_df = calc.pandas(mols)

        # Create a DataFrame with descriptors and valid SMILES
        df_des = pd.concat([descriptors_df, pd.Series(valid_molecules, name='Isomeric SMILES')], axis=1)

        for column in df_des.columns:
            if df_des[column].dtype == object:
                df_des[column] = pd.to_numeric(df_des[column], errors='coerce').fillna(0)
            elif pd.api.types.is_numeric_dtype(df_des[column]):
                df_des[column] = pd.to_numeric(df_des[column], errors='coerce').fillna(0)
            else:
                df_des[column] = 0.0

        # Drop the 'Isomeric SMILES' column
        df_des_only = df_des.drop("Isomeric SMILES", axis=1)

        return df_des_only
    else:
        return None

# Streamlit App
def main():
    # Set the title and description of the app
    st.title("BBB Permeability Prediction Using AI")
    st.write("Predict the BBB Permeability using a Machine Learning and molecular descriptors.")

    # Add a side option menu with additional information if needed
    st.sidebar.title("Options")
    st.sidebar.write("You can enter a SMILES of a molecule to predict its BBB Permeability.")

    # User input for SMILES
    smiles_input = st.text_input("Enter the SMILES :")

    # Check if user provided a SMILES
    if smiles_input:
        # Calculate descriptors and make prediction
        descriptors_df = calculate_descriptors(smiles_input)
        if descriptors_df is not None:
            # Select only the features used during training from 'input_data' based on selected_features
            input_data_selected = descriptors_df[selected_features]

            # Make predictions using the loaded model and the input data with selected features
            prediction = loaded_model.predict(input_data_selected)

            # Display the prediction result
            if prediction == 0:
                st.write("BBB Permeability Prediction: Negative")
            else:
                st.write("BBB Permeability Prediction: Positive")
        else:
            st.write("Invalid SMILES input. Please enter a valid SMILES string.")
    else:
        st.write("Enter a SMILES string to predict its BBB Permeability.")

# Run the Streamlit app
if __name__ == "__main__":
    main()
